% Translated to Java
\chapter{Elementary Programming}
\label{sec:elementary}

Here are some basic programming knowledge. I hope you have seen some of the concepts in this chapter already on other occasions. This is a good opportunity to recap, or to familiarise yourself with C++ if you are not a C++ programmer. I would like to stress that most programming concepts discussed in this piece of notes are transferable to most other programming languages.

% Translated to Java end 

\section*{Further resources (Ch 1-2)}
\addcontentsline{toc}{section}{Further resources (Ch 1-2)}
\href{https://www.youtube.com/watch?v=tvC1WCdV1XU&list=PLAE85DE8440AA6B83}{Bucky's C++ Programming Tutorial}\footnote{Link: \url{https://www.youtube.com/watch?v=tvC1WCdV1XU&list=PLAE85DE8440AA6B83}} (a YouTube playlist) covers most things that you need to know about C++, and also most of the things in this chapter. You only need to watch the first 20-30 videos, as it goes too deep in the later episodes.

\section*{Practicing at home}
Practicing is very important. For example, one of the things I would do back then is to remove the one or two lines that I didn't understand in the materials, and see how they affected the program by printing out the values of the variables at different times. 

Refer to \cref{sec:settingup} on how to run C++ code on your own device.

\section{Structure of a C++ program}
\begin{lstlisting}
//First include the libraries that you are going to use
#include <iostream> 

//A weird line of code that you have to remember every time you write a C++ program.
using namespace std;

int main(){
    cout << "Hello world" << endl;
    return 0;
}
\end{lstlisting}

The main function is the point of entry of the program.

You need to add a semicolon at the end of every statement or else the compiler will shout at you. 

Comments are denoted as \texttt{//}.

\section{Variables}

\textit{A variable is just like an empty box. You can store stuff in it. Technically, it is nothing but a name given to a computer memory. That's it, now go spend rest of your life deciding the perfect variable name.}\footnote{Cited from \cite{variableig}}

It is important to distinguish between initialision of the variable and reassignment of the variable.

\begin{lstlisting}
int score = 70; //initialisation
score = 80; //reassignment
\end{lstlisting}

You have to specify the type of variables when initialising them in C++. Each variable can only be used to store data of a single type. You can see a list of datatypes that C++ offers in \cref{sec:primarydtypes} and we will dedicate our full attention to them in \cref{sec:dtypes}.

It is not compulsory to give an initial value to a variable. If you do not do so, it will be a random number until you reassigns it.

\begin{lstlisting}
int score = 70; //initialisation
cout << score << endl; //unexpected value
score = 80; //reassignment
cout << score << endl; //80
\end{lstlisting}

\section{Console I/O}

\texttt{cout} stands for Console OUTput. You put the things (variable or strings - sequence of characters) that you want to print after the \texttt{cout} keyword, separated by \texttt{<<}. The \texttt{endl} keyword inserts a newline character. Remember to use double quotes for strings.

\texttt{cin} stands for Console INput. You put variables that you would like the output to be stored in after the \texttt{cin} keyword, separated by \texttt{>>}. 

The direction of the arrows may be hard to remember, but it is intuitive once you associate them with the direction of information flow. You want text to flow towards the screen (the \texttt{cout} keyword) when you are outputting, and towards the variables when asking for user input.

\begin{lstlisting}
cout << "What is your score? ";
int score;
cin >> score;
cout << "Your scored " << score << " in this paper." << endl;
\end{lstlisting}

\section{Conditionals}
\subsection{\texttt{if} statements}

\begin{lstlisting}
int score;
cin >> score;
if(score >= 70){
    printf("Good job.\n");
}else if(score >= 40){
    printf("You got a pass.\n");
}else{
    printf("You failed.\n");
}
\end{lstlisting}

\subsection{\texttt{switch case}}

Just looks neater when you are testing on the same variable multiple times. You can of course use if else if else if... 

Note that it only works for int and char, and only equality tests are allowed. For example, the above example on scores could not be replaced using switch case.

Also note that the \textbf{\texttt{break}} keyword is necessary to quit the switch statement, or else it will run the default clause after the \texttt{case} clause.

\begin{lstlisting}
char x;
cin >> x;
switch(x){
    case 'z':
        cout << "It is the last letter of the alphabet." << endl;
        break;
    //this is how you do multiple equality tests
    case 'a':
    case 'e':
    case 'i':
    case 'o':
    case 'u':
        cout << "It is a vowel." << endl;
        break;
    //equivalent to the else clause
    default:
        cout << "It is not a vowel." << endl;
        break;
}
\end{lstlisting}

% Translated to Java

\section{Arrays}
\label{sec:arrayintro}
Arrays store sequences of data of the same type.

\if\proglang1
\begin{lstlisting}
int[] x = {3,1,4,1,5,9,2,6};

System.out.println(x[0]); //3 
System.out.println(x[4]); //5
System.out.println(x[7]); //6 (last element)
System.out.println(x[8]); //Error 
\end{lstlisting}
\else
\begin{lstlisting}
int x[8] = {3,1,4,1,5,9,2,6};
//alternatively: int x[] = {3,1,4,1,5,9,2,6}; length of array can be omitted as the compiler can derive it from the right hand side

cout << x[0] << endl; //3 
cout << x[4] << endl; //5
cout << x[7] << endl; //6 (last element)
cout << x[8] << endl; //unexpected value (Why?)
\end{lstlisting}
\fi

We call the things stored in the array \textbf{elements}. We distinguish different elements using \textbf{index}. The index \textbf{starts from 0}, and ends at $n-1$, where $n$ is the length of the array. The \textbf{length} of the array refers to the maximum number of elements that the array can store, based on the memory allocated when it is \textbf{initialised}. We cannot change the length of the array normally.

\includegraphics[width=12cm]{images/ch2-arrayindex.png}
\vspace{6mm}

There are two ways of initialising arrays. The first way is to hard-code the elements in the array. The length of the array is inferred by the number of elements given, and it cannot be extended afterwards.

\if\proglang1
\begin{lstlisting}
int[] x = {3,1,4,1,5,9,2,6};
\end{lstlisting}
\else
\begin{lstlisting}
int x[] = {3,1,4,1,5,9,2,6};
\end{lstlisting}
\fi

The second way is when you are not quite sure what the elements of the array are yet, but you must still supply the length of the array.

\if\proglang1
\begin{lstlisting}
int[] x = new int[8];
\end{lstlisting}
\else
\begin{lstlisting}
int x[8];
\end{lstlisting}
\fi

% Translated to Java end

\section{Loops}
\subsection{\texttt{for} loops}
Runs the body a specified number of times.

\begin{lstlisting}
int x[8] = {3,1,4,1,5,9,2,6};
int sum = 0;
for(int i = 0; i < 8; i++) { //loops i=0,1,2,3,4,5,6,7
    sum += x[i];
}
cout << sum << endl; //31
\end{lstlisting}

\begin{lstlisting}
int x[8] = {3,1,4,1,5,9,2,6};
int sum = 0;
for(int i = 7; i >= 0; i--) { //loops i=7,6,5,4,3,2,1,0
    sum += x[i];
}
cout << sum << endl; //31
\end{lstlisting}

\subsection{\texttt{while} loops}
Runs the body until the test is false.
\begin{lstlisting}
int x[8] = {3,1,4,1,5,9,2,6};
int sum = 0;
int i = 0;
while(i<8) { 
    sum += x[i]; //loops i=0,1,2,3,4,5,6,7
    i++;
}
cout << sum << endl; //31
\end{lstlisting}

\begin{lstlisting}
int x[8] = {3,1,4,1,5,9,2,6};
int sum = 0;
int i = 0;
while(i<8&&sum<10) { 
    sum += x[i];
    i++;
}
cout << sum << endl; //14
\end{lstlisting}

\subsection{\texttt{do while} loops}
Runs the body until the test is false. The body will run at least once.

\begin{lstlisting}
bool emergency = false;
do{
    printf("EMERGENCY\n"); //will be printed
}while(emergency);
\end{lstlisting}

\begin{lstlisting}
bool emergency = false;
while(emergency){
    printf("EMERGENCY\n"); //will not be printed
}
\end{lstlisting}

This example yields the same result with while loops because the test is true initially, allowing the loop to run at least once.

\begin{lstlisting}
int x[8] = {3,1,4,1,5,9,2,6};
int sum = 0;
int i = 0;
do { 
    sum += x[i]; //loops i=0,1,2,3,4,5,6,7
    i++;
}while(i<8);
cout << sum << endl; //31
\end{lstlisting}

\subsection{Infinite loops}

If the test case is always true (there is nothing in the loop to make the test false). The loop is an infinite loop\index{infinite loop}, where the loop will not terminate (until resources are used up), and the remaining parts of the program can never be run. In this example, EMERGENCY will be printed forever nonstop.

\begin{lstlisting}
bool emergency = true;
while(emergency){
    printf("EMERGENCY\n");
}
destroy_world(); //will not be run
\end{lstlisting}
\vspace{6mm}

\subsection{\texttt{break}}

\texttt{break} allows you to terminate the loop early.

\begin{lstlisting}
int x[8] = {3,1,4,1,5,9,2,6};
int sum = 0;
int i = 0;
while(i<8) { 
    sum += x[i];
    i++;
    if(sum >= 10) break;
}
cout << sum << endl; //14
\end{lstlisting}

\subsection{\texttt{continue}}

\texttt{continue} allows you to jump to the next iteration, skipping the rest of the current iteration early.

\begin{lstlisting}
int x[8] = {3,1,4,1,5,9,2,6};
int sum = 0;
int i = 8;
while(i>0) {
    i--;
    if(x[i] >= 5) continue;
    sum += x[i];
}
cout << sum << endl; //11
\end{lstlisting}

\subsection{Necessity of \texttt{break} and \texttt{continue}}

% Note that all for loops and do while loops can be written as a while loop.

% \begin{lstlisting}[basicstyle=\rmfamily]
% for(int i = 0; i < <target>; i++) <body> === 
% int i = 0; while(i < <target>) <body> i++;
% \end{lstlisting}

% \begin{lstlisting}[basicstyle=\rmfamily]
% do <body> while(<test>); === <body> while(<test>) <body>
% \end{lstlisting}

Note that the use of \texttt{break} and \texttt{continue} can be avoided by modifying the loop condition and using if statements respectively. 

In fact, plenty of other programming languages do not have \texttt{break} and \texttt{continue}. 

\section{2D arrays}

Don't have time to cover, there should be plenty of resources online on this topic.

\begin{lstlisting}
int x[3][] = {{1,4,7},{2,5,8},{3,6,9}};
cout << x[2][1] << endl; //6
\end{lstlisting}

\subsection{Nested loops}

\begin{lstlisting}
int x[3][] = {{1,4,7},{2,5,8},{3,6,9}};
sum = 0;
for(int i=0;i<3;i++)
    for(int j=0;j<3;j++)
        sum += x[i][j];
cout << sum << endl; //45
\end{lstlisting}

% Translated to Java 
\section{\if\proglang1 Methods \else ~Functions \fi}
\label{sec:functions}

\if\proglang1 Methods \else Functions \fi let you organize code better and reduce the amount of repeated code. You can define them by:

\if\proglang1
\begin{lstlisting}[language=,basicstyle=\rmfamily]
public static <return type> <name>(<arguments>){
    return <return value>;
}
\end{lstlisting}
\else
\begin{lstlisting}[language=,basicstyle=\rmfamily]
<return type> function(<arguments>){
    return <return value>;
}
\end{lstlisting}
\fi

For example, this \texttt{fact}\if\proglang1 method \else ~function \fi accepts an integer x, and returns another integer.
\if\proglang1
\begin{lstlisting}
public static int fact(int x){
    int y = 1;
    for(int i = 1; i <= x; i++){
        y *= i;
    }
    return y;
}
\end{lstlisting}
\else
\begin{lstlisting}
int fact(int x){
    int y = 1;
    for(int i = 1; i <= x; i++){
        y *= i;
    }
    return y;
}
//What would happen if we input a negative number?
\end{lstlisting}
\fi

This is how you use a\if\proglang1 method \else ~function \fi: 
You could call it by just supplying the argument.

\if\proglang1
\begin{lstlisting}
    System.out.println(fact(6)); //720
\end{lstlisting}
\else
\begin{lstlisting}
    cout << fact(6) << endl; //720
\end{lstlisting}
\fi

Alternatively, we usually would prefer saving the value returned for later use.

\begin{lstlisting}
    int x = fact(6); //720 is now stored in x
\end{lstlisting}

You could use the \texttt{\textbf{void}} keyword to indicate that a\if\proglang1 method \else ~function \fi does not have a return value. For \texttt{void}\if\proglang1 methods \else ~functions \fi, if there is no explicit \texttt{return;} statement, the\if\proglang1 method \else ~function \fi will automatically quit at the end of the\if\proglang1 method \else ~function \fi. 

\if\proglang1
\begin{lstlisting}
import java.util.Scanner;

public static void giveComment(int score){
    if(score >= 70){
        System.out.println("Good job.");
    }else if(score >= 40){
        System.out.println("You got a pass.");
    }else{
        System.out.println("You failed.");
    }
    //automatically quits here
}

public static void main(String args[]){
    Scanner scanner = new Scanner(System.in);  
    int s = scanner.nextInt();
    giveComment(s);
}
\end{lstlisting}
\else
\begin{lstlisting}
void giveComment(int score){
    if(score >= 70){
        printf("Good job.\n");
    }else if(score >= 40){
        printf("You got a pass.\n");
    }else{
        printf("You failed.\n");
    }
    //automatically quits here
}

int main(){
    int s;
    cin >> s;
    giveComment(s);
    //returning 0 is optional for some C/C++ compilers, it is implied it returns 0 normally
}
\end{lstlisting}
\fi

The main\if\proglang1 method \else ~function \fi is just a\if\proglang1 method \else ~function \fi with no arguments and an integer as a return value. The main\if\proglang1 method \else ~function \fi (specially recognized by the compiler) is the point of entry of the program, the program terminates when the main program returns, returning 0 indicates that there is no error, and returning other integers indicate otherwise.
\vspace{6mm}

Note that the giveComment\if\proglang1 method \else ~function \fi must be placed in front of the main\if\proglang1 method \else ~function \fi, or else the main\if\proglang1 method \else ~function \fi could not call the giveComment\if\proglang1 method \else ~function \fi as the\if\proglang1 method \else ~function \fi has not been defined by the time the compiler reads till the main\if\proglang1 method \else ~function \fi. 


% TODO: https://users.cs.utah.edu/~zachary/computing/lessons/uces-10/uces-10/node11.html
% Translated to Java end